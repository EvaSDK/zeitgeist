#! /usr/bin/python
# -.- coding: utf-8 -.-

# Zeitgeist
#
# Copyright © 2009-2010 Markus Korn <thekorn@gmx.de>
# Copyright © 2010 Mikkel Kamstrup Erlandsen <mikkel.kamstrup@gmail.com>
# Copyright © 2010 Canonical Ltd.
#             By Mikkel Kamstrup Erlandsen <mikkel.kamstrup@gmail.com>
# Copyright © 2011 Collabora Ltd.
#             By Siegfried-Angel Gevatter Pujals <siegfried@gevatter.com>
#             By Seif Lotfy <seif@lotfy.com>
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Lesser General Public License as published by
# the Free Software Foundation, either version 2.1 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import sys
import os
import glob
import commands

import rdflib
from rdflib import RDF, RDFS
from rdflib.plugin import register
try:
	# rdflib2
	from rdflib.syntax.serializers import Serializer
	from rdflib import StringInputSource
	from rdflib.Namespace import Namespace
except ImportError:
	# rdflib3 (LP: #626224)
	from rdflib.serializer import Serializer
	from rdflib.parser import StringInputSource
	from rdflib.namespace import Namespace

NIENS = Namespace("http://www.semanticdesktop.org/ontologies/2007/01/19/nie#")

class SymbolCollection(dict):

	closed = False

	def register(self, name, uri, parents, display_name, doc):
		assert not self.closed
		symbol = Symbol(self, name, uri, parents, display_name, doc)
		self[uri] = symbol

	def post_process(self):
		self.closed = True
		for symbol in self.itervalues():
			for (i, parent) in enumerate(symbol.parents):
				symbol.parents[i] = self[parent]

	def debug_print(self):
		for symbol in self.registered_symbols.itervalues():
			symbol.debug_print()
			print

class Symbol:

	name = None
	uri = None
	parents = None
	display_name = None
	doc = None

	_collection = None
	_children = None

	def __init__(self, collection, name, uri, parents, display_name, doc):
		self._collection = collection
		self.name = name
		self.uri = uri
		self.parents = parents
		self.display_name = display_name
		self.doc = doc

	@property
	def children(self):
		""" Return all direct children of this Symbol. """
		if self._children is None:
			childs = set()
			for symbol in self._collection.itervalues():
				if self in symbol.parents:
					childs.add(symbol)
			self._children = childs
		return self._children

	@property
	def parents_set(self):
		return set((symbol.uri for symbol in self.parents))

	def debug_print(self):
		print "Name: %s" % self.name
		print "  URI: %s" % self.uri
		print "  Display Name: %s" % self.display_name
		print "  Parents: %s" % ', '.join([str(p) for p in self.parents])
		doc = self.doc if len(self.doc) <= 50 else "%s..." % self.doc[:47]
		print "  Description: %s" % doc

	def __str__(self):
		return self.name

	def __doc__(self):
		return self.doc

	def __cmp__(self, other):
		return cmp(self.name, other.name)

	def __hash__(self):
		return self.uri.__hash__()

class Utils:

	@staticmethod
	def escape_chars(text, strip=True):
		text = text.replace("'", "\\'")
		text = text.replace('"', '\\"')
		if strip:
			text = text.strip()
		return text

	@staticmethod
	def camel2upper(name):
		"""
		Convert CamelCase to CAMEL_CASE
		"""
		result = ""
		for i in range(len(name) - 1) :
			if name[i].islower() and name[i+1].isupper():
				result += name[i].upper() + "_"
			else:
				result += name[i].upper()
		result += name[-1].upper()
		return result

	@staticmethod
	def replace_items(item_set, item_map):
		if not item_set:
			return
		for item, value in item_map.iteritems():
			try:
				item_set.remove(item)
			except KeyError:
				# item is not in set
				continue
			else:
				# item was in set, replace it with value
				item_set.add(value)

class OntologyParser:

	symbols = None

	def __init__(self, directory):
		rdfxml = self._load_rdfxml_from_trig_directory(directory)
		self.symbols = self._parse(rdfxml)

	@staticmethod
	def _load_rdfxml_from_trig_directory(directory):
		if not os.path.isdir(directory):
			raise SystemExit, 'Directory doesn\'t exist: %s' % directory
		files = ' '.join(glob.glob(os.path.join(directory, '*.trig')))
		return commands.getoutput(
			"cat %s | rapper -i trig -o rdfxml -I ZeitgeistNamespace - " \
			"2>/dev/null" % files)

	def _parse(self, rdfxml_stream):
		"""
		Parse an RDFXML stream into a SymbolCollection.
		"""
		ontology = rdflib.ConjunctiveGraph()
		ontology.parse(StringInputSource(rdfxml_stream))
		
		def _get_all_classes(*super_classes):
			for cls in super_classes:
				for subclass in ontology.subjects(RDFS.subClassOf, cls):
					yield subclass
					for x in _get_all_classes(subclass):
						yield x
		
		parent_classes = [NIENS['InformationElement'], NIENS['DataObject']]
		symbol_classes = set(_get_all_classes(*parent_classes))
		all_symbols = symbol_classes.union(parent_classes)
		
		symbols = SymbolCollection()
		for symbol in sorted(all_symbols):
			# URI
			uri = str(symbol)

			# Name (for code)
			name = Utils.camel2upper(str(symbol).split("#")[-1])

			# Description
			comments = list(ontology.objects(symbol, RDFS.comment))
			doc = Utils.escape_chars(comments[0] if comments else "")

			# Display name
			labels = list(ontology.objects(symbol, RDFS.label))
			display_name = Utils.escape_chars(labels[0] if labels else name)

			# Parents
			root_type = set(ontology.objects(symbol, RDFS.subClassOf)
				).intersection(all_symbols)
			parents = [str(url) for url in root_type]

			if symbol in symbol_classes:
				assert parents

			# And we have a new Symbol!
			symbols.register(name, uri, parents, display_name, doc)

		symbols.post_process()
		return symbols

class GenericSerializer:

	parser = None
	symbols = None

	def __init__(self, parser):
		self.parser = parser
		self.symbols = parser.symbols

class PythonSerializer(GenericSerializer):

	def dump(self):
		for symbol in sorted(self.symbols.itervalues()):
			parents = symbol.parents_set
			Utils.replace_items(parents, {
				str(NIENS["InformationElement"]): "Interpretation",
				str(NIENS["DataObject"]): "Manifestation" })
			print "Symbol('%s', parent=%r, uri='%s', display_name='%s', " \
			"doc='%s', auto_resolve=False)" % (symbol.name, parents,
				symbol.uri, symbol.display_name, symbol.doc)

class ValaSerializer(GenericSerializer):

	@staticmethod
	def symbol_name(symbol):
		ns, name = symbol.uri[symbol.uri.rfind("/")+1:].split("#")
		return "%s_%s" % (ns.upper(), Utils.camel2upper(name))

	@classmethod
	def build_doc(cls, name, symbol, doc_prefix=""):
		"""
		Build a C-style docstring for gtk-doc processing.
		"""
		uri_link = '<ulink url="%s">%s</ulink>' % (symbol.uri,
			symbol.uri.replace("#", "&num;"))
		doc = symbol.doc

		# List children
		children = ["#" + cls.symbol_name(child) for child in symbol.children]
		if children:
			doc += "\n\n Children: %s" % ", ".join(children)
		else:
			doc += "\n\n Children: None"

		# List parents
		parents = ["#" + cls.symbol_name(parent) for parent in symbol.parents]
		if parents and not parents in (["#INTERPRETATION"], ["#MANIFESTATION"]):
			doc += "\n\n Parents: %s" % ", ".join(parents)
		else:
			doc += "\n\n Parents: None"
	
		# Convert docstring to gtk-doc style C comment
		doc = doc.replace("\n", "\n *")
		doc = "/**\n * %s:\n *\n * %s%s\n * \n * %s\n */" % (
			name, doc_prefix, uri_link, doc)
		return doc

	def dump(self):
		print "namespace Zeitgeist\n{\n"
		for symbol in sorted(self.symbols.itervalues()):
			name = self.symbol_name(symbol)
			# FIXME: (event/subject) interpretation/manifestation
			doc = self.build_doc(name, symbol,
				doc_prefix="Macro defining the interpretation type ")
			print '    %s' % doc.replace('\n', '\n    ').strip()
			print "    public const string %s = \"%s\";" % (name, symbol.uri)
			print
		print "}"

if __name__ == "__main__":
	if len(sys.argv) != 3 or sys.argv[2] not in ('--vala', '--python'):
		raise SystemExit, 'Usage: %s <directory> [--vala|--python]' % \
			sys.argv[0]
	parser = OntologyParser(sys.argv[1])
	python_serializer = PythonSerializer(parser)
	vala_serializer = ValaSerializer(parser)
	if sys.argv[2] == '--vala':
		vala_serializer.dump()
	elif sys.argv[2] == '--python':
		python_serializer.dump()
